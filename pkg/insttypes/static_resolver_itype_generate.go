// +build ignore

package main

import (
	"log"

	. "github.com/dave/jennifer/jen"
	. "github.com/weaveworks/eksctl/pkg/insttypes"
)

// Write a map of maps
//
// Inner maps are keyed by the name of the instance type with values of type EC2InstanceTypeInfo
// Outer maps are keyed by region with values of the inner maps
//
// Usage:
//    go run static_resolver_itype_generate.go
func main() {
	regionalInstanceTypesMap := GenerateRegionalInstanceTypesMap()
	renderGoMap(regionalInstanceTypesMap)
}

func renderGoMap(instTypeMap map[string]map[string]*EC2InstanceTypeInfo) {
	f := NewFile("insttypes")
	f.Comment("This file was generated by static_resolver_itype_generate.go; DO NOT EDIT.")
	f.Line()

	// m := Op("*").Map(String()).Map(String()).Op("*").Id("EC2InstanceTypeInfo").Values(
	m := DictFunc(func(r Dict) {
		for region, itm := range instTypeMap {
			r[Lit(region)] = getInstanceTypesForRegion(itm)
		}
	})

	f.Comment("StaticInstanceTypes is a map that holds a map of instances types in each of the AWS regions supported by eksctl")
	f.Line()
	f.Var().Id("StaticInstanceTypes").
		Map(String()).Map(String()).Op("*").Id("EC2InstanceTypeInfo").Op("=").
		Map(String()).Map(String()).Op("*").Id("EC2InstanceTypeInfo").Values(m)
	f.Line()
	f.Comment("This file was generated by static_resolver_itype_generate.go; DO NOT EDIT.")

	err := f.Save("./static_resolver_itype.go")
	if err != nil {
		log.Fatal(err.Error())
	}
}

func getInstanceTypesForRegion(itm map[string]*EC2InstanceTypeInfo) *Statement {
	return Map(String()).Op("*").Id("EC2InstanceTypeInfo").Values(DictFunc(func(rit Dict) {
		for _, itypeInfo := range itm {
			it := itypeInfo.InstanceType
			rit[Lit(it)] = buildInstTypeInfo(itypeInfo)
		}
	}))
}

func buildInstTypeInfo(instTypeInfo *EC2InstanceTypeInfo) *Statement {
	itypeInfo := instTypeInfo
	var istorInfo EC2InstanceStorageInfo
	if itypeInfo.InstanceStorageInfo == nil {
		istorInfo = EC2InstanceStorageInfo{}
	} else {
		istorInfo = *itypeInfo.InstanceStorageInfo
	}
	istorSupported := itypeInfo.InstanceStorageSupported
	memInfo := itypeInfo.MemoryInfo
	cpuInfo := (itypeInfo.VCpuInfo)
	if istorSupported {
		return Op("&").Id("EC2InstanceTypeInfo").Values(Dict{
			Id("InstanceStorageInfo"): Op("&").Id("EC2InstanceStorageInfo").Values(Dict{
				Id("TotalSizeInGB"): Lit(istorInfo.TotalSizeInGB),
			}),
			Id("InstanceStorageSupported"): Lit(istorSupported),
			Id("InstanceType"):             Lit(itypeInfo.InstanceType),
			Id("MemoryInfo"): Op("&").Id("EC2MemoryInfo").Values(Dict{
				Id("SizeInMiB"): Lit(memInfo.SizeInMiB),
			}),
			Id("VCpuInfo"): Op("&").Id("EC2VCpuInfo").Values(Dict{
				Id("DefaultVCpus"): Lit(cpuInfo.DefaultVCpus),
			}),
		})
	} else {
		return Op("&").Id("EC2InstanceTypeInfo").Values(Dict{
			Id("InstanceStorageInfo"): Op("&").Id("EC2InstanceStorageInfo").Values(Dict{
				Id("TotalSizeInGB"): Lit(DefaultTotalEphemStorageSize),
			}),
			Id("InstanceStorageSupported"): Lit(istorSupported),
			Id("InstanceType"):             Lit(itypeInfo.InstanceType),
			Id("MemoryInfo"): Op("&").Id("EC2MemoryInfo").Values(Dict{
				Id("SizeInMiB"): Lit(memInfo.SizeInMiB),
			}),
			Id("VCpuInfo"): Op("&").Id("EC2VCpuInfo").Values(Dict{
				Id("DefaultVCpus"): Lit(cpuInfo.DefaultVCpus),
			}),
		})
	}
}
